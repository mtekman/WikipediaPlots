
* Accumulate Data

  #+begin_src python :session yes
    import sys
    import requests
    from lxml import html
    #import pickle
    import pandas as pd

    def makeDayStrings():
        "Literally generate days of the week as a tuple"
        dates = {
            29 : ("February",),
            30 : ("September", "April", "June", "November"),
            31 : ("January", "March", "May", "July",
                  "August", "October", "December")
        }
        order = ("January", "February", "March", "April",
                 "May", "June", "July", "August", "September",
                 "October", "November", "December")

        days = []
        for month in order:
            getday = [day for day in dates if month in dates[day]][0]
            for d in range(getday):
                days.append("%s_%d" % (month, (d+1)))
        return(tuple(days))


    def handleADBC(temp):
        if temp.startswith("AD "):
            temp = temp.split("AD ")[1]
        elif temp.endswith(" AD"):
            temp = temp.split(" AD")[0]
        elif temp.endswith(" BC") or temp.endswith(" BCE"):
            temp = "-" + temp.split(" BC")[0]
        elif temp.startswith("BC ") or temp.startswith(" BCE"):
            temp = "-" + temp.split()[1]
        return(temp)


    def getEventsDay(day):
        "Take January_11 and extract the Events, Births, Deaths years"
        page = requests.get("https://en.wikipedia.org/wiki/" + day)
        groups = str(page.content).split("mw-headline")[1:]

        last_valid_headline = None
        headlines = {}

        for group in groups:
            # We assume events, birthdays, holidays in that order
            headline = group.split("\">")[0].split("id=\"")[1]
            data = group.split("<li>")

            if len(data) > 1:
                data = data[1:]

            if headline in ("Events", "Births", "Deaths"):
                last_valid_headline = headline

            # Skip beginning and End
            if last_valid_headline is None:continue
            if headline in ("Holidays and observances", "References"):break

            if last_valid_headline not in headlines:
                headlines[last_valid_headline] = []

            #pdb.set_trace()
            for li in data:
                year = None
                temp = li.split("</a>")[0].strip()

                if len(temp) < 5:continue
                # Clause where a hidden 0 exists...
                # - e.g May_21
                if "color:transparent;" in temp:
                    temp = temp.split('>')[-1]
                    year = int(handleADBC(temp))

                elif temp.startswith("<a href=") or temp.split()[1] == "<a":
                    #<a href="/wiki/.."
                    temp = temp.split(">")[1]
                    # AD and BC handlers
                    temp = handleADBC(temp)

                    ptw = temp.split()
                    if len(ptw)>1:
                        #print(ptw)
                        continue
                    try:
                        year = int(temp)
                    except ValueError:
                        #print(temp)
                        continue
                else:
                    try:
                        year = int(temp.split()[0])
                    except ValueError:
                        #print("CCY", temp)
                        continue

                headlines[last_valid_headline].append(year)
        return(headlines)


    def daysToYearsMap(start=0):
        days = makeDayStrings()[start:]
        daymap = {}
        for day in days:
            events = getEventsDay(day)
            print("%20s %4d %4d %4d" % (
                day,
                len(events["Events"]),
                len(events["Births"]),
                len(events["Deaths"])
            ))
            daymap[day] = events
        return(daymap)

    dog = daysToYearsMap()

    # Create Pandas Dataframe and save to csv
    # format for use in R
    tab = df.from_dict(dog).T
    tab.to_csv("daysToYearsMap.csv")


    # To super wide format
    newdf = pd.DataFrame(columns=["Year","Date", "Events", "Births", "Deaths"])
    for day in dog:
        print(day, end=" : ")
        for typer in ("Events","Births","Deaths"):
            print(typer, end=" ")
            hein = dog[day][typer]
            for year in hein:
                # very inefficient, but screw it.
                newdf = newdf.append(
                    {"Year":year,"Date":day,
                     "Events": typer=="Events",
                     "Births": typer=="Births",
                     "Deaths": typer=="Deaths"} , ignore_index=True)
        print("")


    newdf.to_csv("daysToYearsMap_superwide.csv")
  #+end_src


* TODO Print the CSV using GGplot in R

  #+begin_src R
    library(ggplot2)
    library(data.table)
    require(reshape2)

    ## Reformat CSV to Data.Frame
    tab <- read.csv("daysToYearsMap.csv", row.names=1,
                    stringsAsFactors = F, sep = ",")


    nested2intlist <- function(element){
      "Convert string to integer array of years"
      trimmed <- substr(element, 2, nchar(element)-1)
      strarr <- strsplit(trimmed, split=", ")[[1]]
      return(as.numeric(strarr))
    }

    cod <- data.table(apply(tab, 1:2, nested2intlist),
      keep.rownames = T, check.names = T)

    cod$date <- cod$rn
    cod$month <- as.factor(sub("(.*)_\\d*", "\\1", cod$date))
    cod$day <- as.factor(as.integer(sub(".*_(\\d*)", "\\1", cod$date)))
    cod$rn <- NULL

    m <- melt(cod, id.vars = c("Events"))

    ## ggplot
    events.by.month <- cod$Events




    ggplot(data = cod, aes(x=month, y=Events)) + geom_boxplot()


    ggplot(cod) + geom_boxplot(aes(y=hist(cod$Events)))

    ggplot(cod, aes(x=month, group=month)) + geom_boxplot(aes(y=Events))
  #+end_src

