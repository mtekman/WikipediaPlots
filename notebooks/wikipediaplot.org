
* Accumulate Data

  #+begin_src python :session yes
    import sys
    import requests
    from lxml import html
    #import pickle
    import pandas as pd

    def makeDayStrings():
        "Literally generate days of the week as a tuple"
        dates = {
            29 : ("February",),
            30 : ("September", "April", "June", "November"),
            31 : ("January", "March", "May", "July",
                  "August", "October", "December")
        }
        order = ("January", "February", "March", "April",
                 "May", "June", "July", "August", "September",
                 "October", "November", "December")

        days = []
        for month in order:
            getday = [day for day in dates if month in dates[day]][0]
            for d in range(getday):
                days.append("%s_%d" % (month, (d+1)))
        return(tuple(days))


    def handleADBC(temp):
        if temp.startswith("AD "):
            temp = temp.split("AD ")[1]
        elif temp.endswith(" AD"):
            temp = temp.split(" AD")[0]
        elif temp.endswith(" BC") or temp.endswith(" BCE"):
            temp = "-" + temp.split(" BC")[0]
        elif temp.startswith("BC ") or temp.startswith(" BCE"):
            temp = "-" + temp.split()[1]
        return(temp)


    def getEventsDay(day):
        "Take January_11 and extract the Events, Births, Deaths years"
        page = requests.get("https://en.wikipedia.org/wiki/" + day)
        groups = str(page.content).split("mw-headline")[1:]

        last_valid_headline = None
        headlines = {}

        for group in groups:
            # We assume events, birthdays, holidays in that order
            headline = group.split("\">")[0].split("id=\"")[1]
            data = group.split("<li>")

            if len(data) > 1:
                data = data[1:]

            if headline in ("Events", "Births", "Deaths"):
                last_valid_headline = headline

            # Skip beginning and End
            if last_valid_headline is None:continue
            if headline in ("Holidays and observances", "References"):break

            if last_valid_headline not in headlines:
                headlines[last_valid_headline] = []

            #pdb.set_trace()
            for li in data:
                year = None
                temp = li.split("</a>")[0].strip()

                if len(temp) < 5:continue
                # Clause where a hidden 0 exists...
                # - e.g May_21
                if "color:transparent;" in temp:
                    temp = temp.split('>')[-1]
                    year = int(handleADBC(temp))

                elif temp.startswith("<a href=") or temp.split()[1] == "<a":
                    #<a href="/wiki/.."
                    temp = temp.split(">")[1]
                    # AD and BC handlers
                    temp = handleADBC(temp)

                    ptw = temp.split()
                    if len(ptw)>1:
                        #print(ptw)
                        continue
                    try:
                        year = int(temp)
                    except ValueError:
                        #print(temp)
                        continue
                else:
                    try:
                        year = int(temp.split()[0])
                    except ValueError:
                        #print("CCY", temp)
                        continue

                headlines[last_valid_headline].append(year)
        return(headlines)


    def daysToYearsMap(start=0):
        days = makeDayStrings()[start:]
        daymap = {}
        for day in days:
            events = getEventsDay(day)
            print("%20s %4d %4d %4d" % (
                day,
                len(events["Events"]),
                len(events["Births"]),
                len(events["Deaths"])
            ))
            daymap[day] = events
        return(daymap)

    dog = daysToYearsMap()

    # Create Pandas Dataframe and save to csv
    # format for use in R
    tab = df.from_dict(dog).T
    tab.to_csv("daysToYearsMap.csv")


    # To super wide format
    newdf = pd.DataFrame(columns=["Year","Date", "Events", "Births", "Deaths"])
    for day in dog:
        print(day, end=" : ")
        for typer in ("Events","Births","Deaths"):
            print(typer, end=" ")
            hein = dog[day][typer]
            for year in hein:
                # very inefficient, but screw it.
                newdf = newdf.append(
                    {"Year":year,"Date":day,
                     "Events": typer=="Events",
                     "Births": typer=="Births",
                     "Deaths": typer=="Deaths"} , ignore_index=True)
        print("")


    newdf.to_csv("daysToYearsMap_superwide.csv")
  #+end_src


* Print the CSV using GGplot in R

** Initial attempt using compact format

Trying to plot a boxplot when the data is structured from tab["January_1"]["Events"] = Array[years] is a pain in the butt. I tried reshaping/recasting it to a long format within R, but that was an exercise in futility. 

   #+begin_src R
     library(ggplot2)
     library(data.table)
     require(reshape2)

     ## Reformat CSV to Data.Frame
     tab <- read.csv("daysToYearsMap.csv", row.names=1,
                     stringsAsFactors = F, sep = ",")


     nested2intlist <- function(element){
       "Convert string to integer array of years"
       trimmed <- substr(element, 2, nchar(element)-1)
       strarr <- strsplit(trimmed, split=", ")[[1]]
       return(as.numeric(strarr))
     }

     cod <- data.table(apply(tab, 1:2, nested2intlist),
       keep.rownames = T, check.names = T)

     cod$date <- cod$rn
     cod$month <- as.factor(sub("(.*)_\\d*", "\\1", cod$date))
     cod$day <- as.factor(as.integer(sub(".*_(\\d*)", "\\1", cod$date)))
     cod$rn <- NULL

     m <- melt(cod, id.vars = c("Events"))

     ## ggplot
     events.by.month <- cod$Events




     ggplot(data = cod, aes(x=month, y=Events)) + geom_boxplot()


     ggplot(cod) + geom_boxplot(aes(y=hist(cod$Events)))

     ggplot(cod, aes(x=month, group=month)) + geom_boxplot(aes(y=Events))
   #+end_src

I abandoned this approach and redid the python part above to give a super wide format so that each year is an observation and that variables are Year, Date, isEvent, isBirth, isDeath.

** Second attempt using wide format

   #+begin_src R
     library(ggplot2)
     #library(data.table)
     #require(reshape2)

     ## Reformat CSV to Data.Frame
     tab <- read.csv("daysToYearsMap_superwide.csv",
                     row.names=1,
                     stringsAsFactors = F, sep = ",")

     tab$Month <- factor(sub("(.*)_\\d*", "\\1", tab$Date),
                         levels=c("January", "February", "March", "April", "May",
                                  "June", "July", "August", "September", "October",
                                  "November", "December"))
     tab$Day <- factor(as.integer(sub(".*_(\\d*)", "\\1", tab$Date)),
                       levels=seq(1,31))

     ##### Months #####
     # Feb, Jan, Oct seem to have a few dates nearer to 0 AD
     ggplot(tab, aes(x=Month, y=Year, group=Month)) + geom_violin(scale="count") + ggtitle("Months with Significant Years")

     # Feb, Jan, Oct seem to have a few dates nearer to 0 AD
     ggplot(tab[tab$Year > 0,], aes(x=Month, y=Year, group=Month)) + geom_violin(scale="count") + ggtitle("Months with Significant Years > 0 AD")

     # Virtually no difference
     ggplot(tab[tab$Year > 1000,], aes(x=Month, y=Year, group=Month)) + geom_violin(scale="count") + ggtitle("Months with Significant Years > 1000 AD")

     # Virtually no difference
     ggplot(tab[tab$Year > 1900,], aes(x=Month, y=Year, group=Month)) + geom_boxplot() + ggtitle("Months with Significant Years > 1900 AD")

     # Virtually no difference
     ggplot(tab[tab$Year > 2000,], aes(x=Month, y=Year, group=Month)) + geom_boxplot() + ggtitle("Months with Significant Years > 2000 AD") + scale_y_continuous(breaks = seq(2000, 2020, by = 2))

     # Feb, Jan, Oct seem to have a lot of dates nearer to 0 AD
     ggplot(tab[tab$Year < 1900,], aes(x=Month, y=Year, group=Month)) + geom_violin() + ggtitle("Months with Significant Years < 1900 AD")

     # Big Feb, Jan, Oct difference seems to come from less 500 AD and peaks around 20 AD.
     ggplot(tab[tab$Year < 1000 & tab$Year > -500,], aes(x=Month, y=Year, color=Month)) + geom_boxplot() + ggtitle("500 AD < Months with Significant Years < 1000 AD") + scale_y_continuous(breaks = seq(-500, 1000, by = 100))

     # Feb is down, August and December up.
     ggplot(tab[tab$Year < 0,], aes(x=Month, y=Year, group=Month)) + geom_boxplot() + ggtitle("Months with Significant Years (BC)") + scale_y_continuous(breaks = seq(-4000, 0, by = 200))

     ### Days
     # 1 - No major differences -- 5, 12, 22 seem significant around 0 AD 
     ggplot(tab, aes(x=Day, y=Year)) + geom_violin(scale="count") + ggtitle("Days with Significant Years") + scale_y_continuous(breaks = c(seq(-100, 100, by = 100),seq(1700,2000, by=100)))

     # 2 - Zoomed version of 1
     ggplot(tab[tab$Year > -100,], aes(x=Day, y=Year)) + geom_violin(scale="count") + ggtitle("Days with Significant Years ( > 100 BC )") + scale_y_continuous(breaks = c(seq(-100, 100, by = 100), seq(1700,2000, by=100)))

     # 3 - Zoomed version of 2
     #     -- Day 15 seems to have crazy range
     ggplot(tab[tab$Year > -100 & tab$Year < 100,], aes(x=Day, y=Year)) + geom_boxplot() + ggtitle("Days with Significant Years ( 100 BC - 100 AD )")

     # 4 - 
   #+end_src

